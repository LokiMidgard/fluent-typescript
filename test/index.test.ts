import dedent from 'dedent-js'
import { updateGlobalState } from '../src/global-state'
const { start, updateContent, buildFluentTypeModule } = require('../src')

describe('With vanilla target', () => {
  afterEach(() => updateGlobalState({ type: 'reset' }))

  test('Should match the types definitions', async () => {
    const fixturePtFirstVersion = dedent`
      hello = Olá { $firstName }
      how-are-you = Como você está?
      bye = Tchau
    `
    const fixtureJp = dedent`
      hello = こんにちは{ $lastName }
      how-are-you = お元気ですか？
    `

    start([
      { path: 'pt.ftl', content: fixturePtFirstVersion },
      { path: 'jp.ftl', content: fixtureJp },
    ])

    const fluentTypeModuleFirstVersion = buildFluentTypeModule('vanilla')
    expect(fluentTypeModuleFirstVersion).toBe(dedent`
      // This file is automatically generated.
      // Please do not change this file!

      type Message0<T extends MessagesKey0> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      import { FluentBundle, FluentVariable } from '@fluent/bundle'

      declare global {
        interface FluentBundleTyped extends FluentBundle {
          getMessage<T extends MessagesKey0>(id: T): Message0<T>
      formatPattern<T extends MessagesKey0>(...args: PatternArguments0<T>): string
        }
      }

      type MessagesKey0 = 'hello' |
      'how-are-you' |
      'bye'
      type PatternArguments0<T extends MessagesKey0> = (
        T extends 'hello'
        ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
      T extends 'how-are-you'
        ? [T]:
      T extends 'bye'
        ? [T]
        : never
      )
    `)

    const fixturePtSecondVersion = dedent`
      hello = Olá { $firstName }
      how-are-you = Como você está?
    `
    updateContent({ path: 'pt.ftl', content: fixturePtSecondVersion })

    const fluentTypeModuleSecondVersion = buildFluentTypeModule('vanilla')
    expect(fluentTypeModuleSecondVersion).toBe(dedent`
      // This file is automatically generated.
      // Please do not change this file!

      type Message0<T extends MessagesKey0> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      import { FluentBundle, FluentVariable } from '@fluent/bundle'

      declare global {
        interface FluentBundleTyped extends FluentBundle {
          getMessage<T extends MessagesKey0>(id: T): Message0<T>
      formatPattern<T extends MessagesKey0>(...args: PatternArguments0<T>): string
        }
      }

      type MessagesKey0 = 'hello' |
      'how-are-you'
      type PatternArguments0<T extends MessagesKey0> = (
        T extends 'hello'
        ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
      T extends 'how-are-you'
        ? [T]
        : never
      )
    `)
  })

  test('Should match when split the messages', async () => {
    const fixture = dedent`
      message0 = foo
      message1 = foo
      message2 = foo
      message3 = foo
      message4 = foo
    `

    start([
      { path: 'pt.ftl', content: fixture },
    ])

    const fluentTypeModule = buildFluentTypeModule('vanilla', { chuckSize: 3 })
    expect(fluentTypeModule).toBe(dedent`
      // This file is automatically generated.
      // Please do not change this file!

      type Message0<T extends MessagesKey0> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      type Message1<T extends MessagesKey1> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      import { FluentBundle, FluentVariable } from '@fluent/bundle'

      declare global {
        interface FluentBundleTyped extends FluentBundle {
          getMessage<T extends MessagesKey0>(id: T): Message0<T>
      formatPattern<T extends MessagesKey0>(...args: PatternArguments0<T>): string
          getMessage<T extends MessagesKey1>(id: T): Message1<T>
      formatPattern<T extends MessagesKey1>(...args: PatternArguments1<T>): string
        }
      }

      type MessagesKey0 = 'message0' |
      'message1' |
      'message2'

      type MessagesKey1 = 'message3' |
      'message4'
      type PatternArguments0<T extends MessagesKey0> = (
        T extends 'message0'
        ? [T]:
      T extends 'message1'
        ? [T]:
      T extends 'message2'
        ? [T]
        : never
      )

      type PatternArguments1<T extends MessagesKey1> = (
        T extends 'message3'
        ? [T]:
      T extends 'message4'
        ? [T]
        : never
      )
    `)
  })
})

describe('With react-18next target', () => {
  afterEach(() => updateGlobalState({ type: 'reset' }))

  test('Should match the types definitions', async () => {
    const fixturePtFirstVersion = dedent`
      hello = Olá { $firstName }
      how-are-you = Como você está?
      bye = Tchau
    `
    const fixtureJp = dedent`
      hello = こんにちは{ $lastName }
      how-are-you = お元気ですか？
    `

    start([
      { path: 'pt.ftl', content: fixturePtFirstVersion },
      { path: 'jp.ftl', content: fixtureJp },
    ])

    const fluentTypeModuleFirstVersion = buildFluentTypeModule('react-18next')
    expect(fluentTypeModuleFirstVersion).toBe(dedent`
      // This file is automatically generated.
      // Please do not change this file!

      type Message0<T extends MessagesKey0> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      import { FluentVariable } from '@fluent/bundle'

      declare module 'react-i18next' {
        interface UseTranslationResponsePatched extends Omit<UseTranslationResponse, 't'> {
          t<T extends MessagesKey0>(...args: PatternArguments0<T>): string
        }

        function useTranslation(ns?: Namespace, options?: UseTranslationOptions): UseTranslationResponsePatched
      }

      type MessagesKey0 = 'hello' |
      'how-are-you' |
      'bye'
      type PatternArguments0<T extends MessagesKey0> = (
        T extends 'hello'
        ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
      T extends 'how-are-you'
        ? [T]:
      T extends 'bye'
        ? [T]
        : never
      )
    `)

    const fixturePtSecondVersion = dedent`
      hello = Olá { $firstName }
      how-are-you = Como você está?
    `
    updateContent({ path: 'pt.ftl', content: fixturePtSecondVersion })

    const fluentTypeModuleSecondVersion = buildFluentTypeModule('react-18next')
    expect(fluentTypeModuleSecondVersion).toBe(dedent`
      // This file is automatically generated.
      // Please do not change this file!

      type Message0<T extends MessagesKey0> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      import { FluentVariable } from '@fluent/bundle'

      declare module 'react-i18next' {
        interface UseTranslationResponsePatched extends Omit<UseTranslationResponse, 't'> {
          t<T extends MessagesKey0>(...args: PatternArguments0<T>): string
        }

        function useTranslation(ns?: Namespace, options?: UseTranslationOptions): UseTranslationResponsePatched
      }

      type MessagesKey0 = 'hello' |
      'how-are-you'
      type PatternArguments0<T extends MessagesKey0> = (
        T extends 'hello'
        ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
      T extends 'how-are-you'
        ? [T]
        : never
      )
    `)
  })

  test('Should match when split the messages', async () => {
    const fixture = dedent`
      message0 = foo
      message1 = foo
      message2 = foo
      message3 = foo
      message4 = foo
    `

    start([
      { path: 'pt.ftl', content: fixture },
    ])

    const fluentTypeModule = buildFluentTypeModule('react-18next', { chuckSize: 3 })
    expect(fluentTypeModule).toBe(dedent`
      // This file is automatically generated.
      // Please do not change this file!

      type Message0<T extends MessagesKey0> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      type Message1<T extends MessagesKey1> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      import { FluentVariable } from '@fluent/bundle'

      declare module 'react-i18next' {
        interface UseTranslationResponsePatched extends Omit<UseTranslationResponse, 't'> {
          t<T extends MessagesKey0>(...args: PatternArguments0<T>): string
          t<T extends MessagesKey1>(...args: PatternArguments1<T>): string
        }
      
        function useTranslation(ns?: Namespace, options?: UseTranslationOptions): UseTranslationResponsePatched
      }

      type MessagesKey0 = 'message0' |
      'message1' |
      'message2'

      type MessagesKey1 = 'message3' |
      'message4'
      type PatternArguments0<T extends MessagesKey0> = (
        T extends 'message0'
        ? [T]:
      T extends 'message1'
        ? [T]:
      T extends 'message2'
        ? [T]
        : never
      )

      type PatternArguments1<T extends MessagesKey1> = (
        T extends 'message3'
        ? [T]:
      T extends 'message4'
        ? [T]
        : never
      )
    `)
  })
})

describe('With fluent-react target', () => {
  afterEach(() => updateGlobalState({ type: 'reset' }))

  test('Should match the types definitions', async () => {
    const fixturePtFirstVersion = dedent`
      hello = Olá { $firstName }
      how-are-you = Como você está?
      bye = Tchau
    `
    const fixtureJp = dedent`
      hello = こんにちは{ $lastName }
      how-are-you = お元気ですか？
    `

    start([
      { path: 'pt.ftl', content: fixturePtFirstVersion },
      { path: 'jp.ftl', content: fixtureJp },
    ])

    const fluentTypeModuleFirstVersion = buildFluentTypeModule('fluent-react')
    expect(fluentTypeModuleFirstVersion).toBe(dedent`
      // This file is automatically generated.
      // Please do not change this file!

      type Message0<T extends MessagesKey0> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      import { FluentVariable } from '@fluent/bundle'
      import { LocalizedProps } from '@fluent/react'
      import { ReactElement } from 'react'

      declare module '@fluent/react' {
        type LocalizedPropsWithoutIdAndVars = Omit<Omit<LocalizedProps, 'id'>, 'vars'>

        type LocalizedPropsPatched0<T extends MessagesKey0> = (
        PatternArguments0<T>[1] extends undefined
          ? {
            typed: true
            id: T
          } & LocalizedPropsWithoutIdAndVars
          : {
            typed: true
            id: T
            vars: PatternArguments0<T>[1]
          } & LocalizedPropsWithoutIdAndVars
      )

      function Localized<T extends MessagesKey0>(props: LocalizedPropsPatched0<T>): ReactElement;
      }

      type MessagesKey0 = 'hello' |
      'how-are-you' |
      'bye'
      type PatternArguments0<T extends MessagesKey0> = (
        T extends 'hello'
        ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
      T extends 'how-are-you'
        ? [T]:
      T extends 'bye'
        ? [T]
        : never
      )
    `)

    const fixturePtSecondVersion = dedent`
      hello = Olá { $firstName }
      how-are-you = Como você está?
    `
    updateContent({ path: 'pt.ftl', content: fixturePtSecondVersion })

    const fluentTypeModuleSecondVersion = buildFluentTypeModule('fluent-react')
    expect(fluentTypeModuleSecondVersion).toBe(dedent`
      // This file is automatically generated.
      // Please do not change this file!

      type Message0<T extends MessagesKey0> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      import { FluentVariable } from '@fluent/bundle'
      import { LocalizedProps } from '@fluent/react'
      import { ReactElement } from 'react'

      declare module '@fluent/react' {
        type LocalizedPropsWithoutIdAndVars = Omit<Omit<LocalizedProps, 'id'>, 'vars'>

        type LocalizedPropsPatched0<T extends MessagesKey0> = (
        PatternArguments0<T>[1] extends undefined
          ? {
            typed: true
            id: T
          } & LocalizedPropsWithoutIdAndVars
          : {
            typed: true
            id: T
            vars: PatternArguments0<T>[1]
          } & LocalizedPropsWithoutIdAndVars
      )

      function Localized<T extends MessagesKey0>(props: LocalizedPropsPatched0<T>): ReactElement;
      }

      type MessagesKey0 = 'hello' |
      'how-are-you'
      type PatternArguments0<T extends MessagesKey0> = (
        T extends 'hello'
        ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
      T extends 'how-are-you'
        ? [T]
        : never
      )
    `)
  })

  test('Should match when split the messages', async () => {
    const fixture = dedent`
      message0 = foo
      message1 = foo
      message2 = foo
      message3 = foo
      message4 = foo
    `

    start([
      { path: 'pt.ftl', content: fixture },
    ])

    const fluentTypeModule = buildFluentTypeModule('fluent-react', { chuckSize: 3 })
    expect(fluentTypeModule).toBe(dedent`
      // This file is automatically generated.
      // Please do not change this file!

      type Message0<T extends MessagesKey0> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      type Message1<T extends MessagesKey1> = {
        id: T
        value: T
        attributes: Record<string, T>
      }

      import { FluentVariable } from '@fluent/bundle'
      import { LocalizedProps } from '@fluent/react'
      import { ReactElement } from 'react'

      declare module '@fluent/react' {
        type LocalizedPropsWithoutIdAndVars = Omit<Omit<LocalizedProps, 'id'>, 'vars'>

        type LocalizedPropsPatched0<T extends MessagesKey0> = (
        PatternArguments0<T>[1] extends undefined
          ? {
            typed: true
            id: T
          } & LocalizedPropsWithoutIdAndVars
          : {
            typed: true
            id: T
            vars: PatternArguments0<T>[1]
          } & LocalizedPropsWithoutIdAndVars
      )

      function Localized<T extends MessagesKey0>(props: LocalizedPropsPatched0<T>): ReactElement;
          type LocalizedPropsPatched1<T extends MessagesKey1> = (
        PatternArguments1<T>[1] extends undefined
          ? {
            typed: true
            id: T
          } & LocalizedPropsWithoutIdAndVars
          : {
            typed: true
            id: T
            vars: PatternArguments1<T>[1]
          } & LocalizedPropsWithoutIdAndVars
      )

      function Localized<T extends MessagesKey1>(props: LocalizedPropsPatched1<T>): ReactElement;
      }

      type MessagesKey0 = 'message0' |
      'message1' |
      'message2'

      type MessagesKey1 = 'message3' |
      'message4'
      type PatternArguments0<T extends MessagesKey0> = (
        T extends 'message0'
        ? [T]:
      T extends 'message1'
        ? [T]:
      T extends 'message2'
        ? [T]
        : never
      )

      type PatternArguments1<T extends MessagesKey1> = (
        T extends 'message3'
        ? [T]:
      T extends 'message4'
        ? [T]
        : never
      )
    `)
  })
})
