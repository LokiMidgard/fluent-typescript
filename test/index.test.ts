import dedent from 'dedent-js'
const { start, updateContent, buildFluentTypeModule } = require('../src')

test('Should match the types definitions for vanilla target', async () => {
  const fixturePtFirstVersion = dedent`
    hello = Olá { $firstName }
    how-are-you = Como você está?
    bye = Tchau
  `
  const fixtureJp = dedent`
    hello = こんにちは{ $lastName }
    how-are-you = お元気ですか？
  `

  start([
    { path: 'pt.ftl', content: fixturePtFirstVersion },
    { path: 'jp.ftl', content: fixtureJp },
  ])

  const fluentTypeModuleFirstVersion = buildFluentTypeModule('vanilla')
  expect(fluentTypeModuleFirstVersion).toBe(dedent`
    // This file is automatically generated.
    // Please do not change this file!

    type Message0<T extends MessagesKey0> = {
      id: T
      value: T
      attributes: Record<string, T>
    }

    import { FluentBundle, FluentVariable } from '@fluent/bundle'

    declare global {
      interface FluentBundleTyped extends FluentBundle {
        getMessage<T extends MessagesKey0>(id: T): Message0<T>
        formatPattern<T extends MessagesKey0>(...args: PatternArguments0<T>) : string
      }
    }

    type MessagesKey0 = 'hello' |
    'how-are-you' |
    'bye'
    type PatternArguments0<T extends MessagesKey0> = (
      T extends 'hello'
      ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
    T extends 'how-are-you'
      ? [T]:
    T extends 'bye'
      ? [T]
      : never
    )
  `)

  const fixturePtSecondVersion = dedent`
    hello = Olá { $firstName }
    how-are-you = Como você está?
  `
  updateContent({ path: 'pt.ftl', content: fixturePtSecondVersion })

  const fluentTypeModuleSecondVersion = buildFluentTypeModule('vanilla')
  expect(fluentTypeModuleSecondVersion).toBe(dedent`
    // This file is automatically generated.
    // Please do not change this file!

    type Message0<T extends MessagesKey0> = {
      id: T
      value: T
      attributes: Record<string, T>
    }

    import { FluentBundle, FluentVariable } from '@fluent/bundle'

    declare global {
      interface FluentBundleTyped extends FluentBundle {
        getMessage<T extends MessagesKey0>(id: T): Message0<T>
        formatPattern<T extends MessagesKey0>(...args: PatternArguments0<T>) : string
      }
    }

    type MessagesKey0 = 'hello' |
    'how-are-you'
    type PatternArguments0<T extends MessagesKey0> = (
      T extends 'hello'
      ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
    T extends 'how-are-you'
      ? [T]
      : never
    )
  `)
})

test('Should match the types definitions for react-18next target', async () => {
  const fixturePtFirstVersion = dedent`
    hello = Olá { $firstName }
    how-are-you = Como você está?
    bye = Tchau
  `
  const fixtureJp = dedent`
    hello = こんにちは{ $lastName }
    how-are-you = お元気ですか？
  `

  start([
    { path: 'pt.ftl', content: fixturePtFirstVersion },
    { path: 'jp.ftl', content: fixtureJp },
  ])

  const fluentTypeModuleFirstVersion = buildFluentTypeModule('react-18next')
  expect(fluentTypeModuleFirstVersion).toBe(dedent`
    // This file is automatically generated.
    // Please do not change this file!

    type Message0<T extends MessagesKey0> = {
      id: T
      value: T
      attributes: Record<string, T>
    }

    import { FluentVariable } from '@fluent/bundle'
    import { TransProps } from 'react-i18next'

    declare module 'react-i18next' {
      interface UseTranslationResponsePatched extends Omit<UseTranslationResponse, 't'> {
        t<T extends MessagesKey0>(...args: PatternArguments0<T>) : string
      }

      function useTranslation(ns?: Namespace, options?: UseTranslationOptions): UseTranslationResponsePatched
    }

    type MessagesKey0 = 'hello' |
    'how-are-you' |
    'bye'
    type PatternArguments0<T extends MessagesKey0> = (
      T extends 'hello'
      ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
    T extends 'how-are-you'
      ? [T]:
    T extends 'bye'
      ? [T]
      : never
    )
  `)

  const fixturePtSecondVersion = dedent`
    hello = Olá { $firstName }
    how-are-you = Como você está?
  `
  updateContent({ path: 'pt.ftl', content: fixturePtSecondVersion })

  const fluentTypeModuleSecondVersion = buildFluentTypeModule('react-18next')
  expect(fluentTypeModuleSecondVersion).toBe(dedent`
    // This file is automatically generated.
    // Please do not change this file!

    type Message0<T extends MessagesKey0> = {
      id: T
      value: T
      attributes: Record<string, T>
    }

    import { FluentVariable } from '@fluent/bundle'
    import { TransProps } from 'react-i18next'

    declare module 'react-i18next' {
      interface UseTranslationResponsePatched extends Omit<UseTranslationResponse, 't'> {
        t<T extends MessagesKey0>(...args: PatternArguments0<T>) : string
      }

      function useTranslation(ns?: Namespace, options?: UseTranslationOptions): UseTranslationResponsePatched
    }

    type MessagesKey0 = 'hello' |
    'how-are-you'
    type PatternArguments0<T extends MessagesKey0> = (
      T extends 'hello'
      ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
    T extends 'how-are-you'
      ? [T]
      : never
    )
  `)
})

test('Should match the types definitions for fluent-react target', async () => {
  const fixturePtFirstVersion = dedent`
    hello = Olá { $firstName }
    how-are-you = Como você está?
    bye = Tchau
  `
  const fixtureJp = dedent`
    hello = こんにちは{ $lastName }
    how-are-you = お元気ですか？
  `

  start([
    { path: 'pt.ftl', content: fixturePtFirstVersion },
    { path: 'jp.ftl', content: fixtureJp },
  ])

  const fluentTypeModuleFirstVersion = buildFluentTypeModule('fluent-react')
  expect(fluentTypeModuleFirstVersion).toBe(dedent`
    // This file is automatically generated.
    // Please do not change this file!

    type Message<T extends MessagesKey> = {
      id: T
      value: T
      attributes: Record<string, T>
    }

    import { FluentVariable } from '@fluent/bundle'
    import { LocalizedProps } from '@fluent/react'
    import { ReactElement } from 'react'

    declare module '@fluent/react' {
      type LocalizedPropsWithoutIdAndVars = Omit<Omit<LocalizedProps, 'id'>, 'vars'>

      type LocalizedPropsPatched<T extends MessagesKey> = (
        PatternArguments<T>[1] extends undefined
          ? {
            typed: true
            id: T
          } & LocalizedPropsWithoutIdAndVars
          : {
            typed: true
            id: T
            vars: PatternArguments<T>[1]
          } & LocalizedPropsWithoutIdAndVars
      )

      function Localized<T extends MessagesKey>(props: LocalizedPropsPatched<T>): ReactElement;
    }

    type MessagesKey = 'hello' |
    'how-are-you' |
    'bye'
    type PatternArguments<T extends MessagesKey> = (
      T extends 'hello'
      ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
    T extends 'how-are-you'
      ? [T]:
    T extends 'bye'
      ? [T]
      : never
    )
  `)

  const fixturePtSecondVersion = dedent`
    hello = Olá { $firstName }
    how-are-you = Como você está?
  `
  updateContent({ path: 'pt.ftl', content: fixturePtSecondVersion })

  const fluentTypeModuleSecondVersion = buildFluentTypeModule('fluent-react')
  expect(fluentTypeModuleSecondVersion).toBe(dedent`
    // This file is automatically generated.
    // Please do not change this file!

    type Message<T extends MessagesKey> = {
      id: T
      value: T
      attributes: Record<string, T>
    }

    import { FluentVariable } from '@fluent/bundle'
    import { LocalizedProps } from '@fluent/react'
    import { ReactElement } from 'react'

    declare module '@fluent/react' {
      type LocalizedPropsWithoutIdAndVars = Omit<Omit<LocalizedProps, 'id'>, 'vars'>

      type LocalizedPropsPatched<T extends MessagesKey> = (
        PatternArguments<T>[1] extends undefined
          ? {
            typed: true
            id: T
          } & LocalizedPropsWithoutIdAndVars
          : {
            typed: true
            id: T
            vars: PatternArguments<T>[1]
          } & LocalizedPropsWithoutIdAndVars
      )

      function Localized<T extends MessagesKey>(props: LocalizedPropsPatched<T>): ReactElement;
    }

    type MessagesKey = 'hello' |
    'how-are-you'
    type PatternArguments<T extends MessagesKey> = (
      T extends 'hello'
      ? [T, { 'firstName': FluentVariable,'lastName': FluentVariable }]:
    T extends 'how-are-you'
      ? [T]
      : never
    )
  `)
})

test('Should add multiple messages', async () => {
  const fixturePt = dedent`
  t1 = Tetst 1
  t2 = Tetst 2
  t3 = Tetst 3
  t4 = Tetst 4
  t5 = Tetst 5
  t6 = Tetst 6
  t7 = Tetst 7
  t8 = Tetst 8
  t9 = Tetst 9
  t10 = Tetst 10
  t11 = Tetst 11
  t12 = Tetst 12
  t13 = Tetst 13
  t14 = Tetst 14
  t15 = Tetst 15
  t16 = Tetst 16
  t17 = Tetst 17
  t18 = Tetst 18
  t19 = Tetst 19
  t20 = Tetst 20
  t21 = Tetst 21
  t22 = Tetst 22
  t23 = Tetst 23
  t24 = Tetst 24
  t25 = Tetst 25
  t26 = Tetst 26
  t27 = Tetst 27
    `
  const fixtureJp = dedent`
  t1 = Tetst 1
  t2 = Tetst 2
  t3 = Tetst 3
  t4 = Tetst 4
  t5 = Tetst 5
  t6 = Tetst 6
  t7 = Tetst 7
  t8 = Tetst 8
  t9 = Tetst 9
  t10 = Tetst 10
  t11 = Tetst 11
  t12 = Tetst 12
  t13 = Tetst 13
  t14 = Tetst 14
  t15 = Tetst 15
  t16 = Tetst 16
  t17 = Tetst 17
  t18 = Tetst 18
  t19 = Tetst 19
  t20 = Tetst 20
  t21 = Tetst 21
  t22 = Tetst 22
  t23 = Tetst 23
  t24 = Tetst 24
  t25 = Tetst 25
  t26 = Tetst 26
  t27 = Tetst 27
    `

  start([
    { path: 'pt.ftl', content: fixturePt },
    { path: 'jp.ftl', content: fixtureJp },
  ])

  const fluentTypeModuleFirstVersion = buildFluentTypeModule('vanilla')
  expect(fluentTypeModuleFirstVersion).toBe(dedent`
  // This file is automatically generated.
  // Please do not change this file!
  
  type Message0<T extends MessagesKey0> = {
    id: T
    value: T
    attributes: Record<string, T>
  }
  
  type Message1<T extends MessagesKey1> = {
    id: T
    value: T
    attributes: Record<string, T>
  }
  
  import { FluentBundle, FluentVariable } from '@fluent/bundle'
  
  declare global {
    interface FluentBundleTyped extends FluentBundle {
      getMessage<T extends MessagesKey0>(id: T): Message0<T>
      formatPattern<T extends MessagesKey0>(...args: PatternArguments0<T>) : string
      getMessage<T extends MessagesKey1>(id: T): Message1<T>
      formatPattern<T extends MessagesKey1>(...args: PatternArguments1<T>) : string
    }
  }
  
  type MessagesKey0 = 't1' |
  't2' |
  't3' |
  't4' |
  't5' |
  't6' |
  't7' |
  't8' |
  't9' |
  't10' |
  't11' |
  't12' |
  't13' |
  't14' |
  't15' |
  't16' |
  't17' |
  't18' |
  't19' |
  't20' |
  't21' |
  't22' |
  't23' |
  't24' |
  't25'
  
  type MessagesKey1 = 't26' |
  't27'
  type PatternArguments0<T extends MessagesKey0> = (
    T extends 't1'
    ? [T]:
  T extends 't2'
    ? [T]:
  T extends 't3'
    ? [T]:
  T extends 't4'
    ? [T]:
  T extends 't5'
    ? [T]:
  T extends 't6'
    ? [T]:
  T extends 't7'
    ? [T]:
  T extends 't8'
    ? [T]:
  T extends 't9'
    ? [T]:
  T extends 't10'
    ? [T]:
  T extends 't11'
    ? [T]:
  T extends 't12'
    ? [T]:
  T extends 't13'
    ? [T]:
  T extends 't14'
    ? [T]:
  T extends 't15'
    ? [T]:
  T extends 't16'
    ? [T]:
  T extends 't17'
    ? [T]:
  T extends 't18'
    ? [T]:
  T extends 't19'
    ? [T]:
  T extends 't20'
    ? [T]:
  T extends 't21'
    ? [T]:
  T extends 't22'
    ? [T]:
  T extends 't23'
    ? [T]:
  T extends 't24'
    ? [T]:
  T extends 't25'
    ? [T]
    : never
  )
  
  type PatternArguments1<T extends MessagesKey1> = (
    T extends 't26'
    ? [T]:
  T extends 't27'
    ? [T]
    : never
  )
  `)
})